<!-- toc -->

# Oracle中的shrink space

## 一、概述
数据库在日常使用过程中，不断的insert，delete，update操作，导致表和索引出现碎片是在所难免的事情，碎片多了，sql的执行效率自然就差了，道理很简单，高水位线（HWL）下的许多数据块都是无数据的，但全表扫描的时候要扫描到高水位线的数据块，也就是说oracle要做许多的无用功！

在9i的时候，使用move来进行减少碎片的操作：
```
alter table xxx move    高水位以下合并碎片，不移动高水位
alter table xxx move compress    高水位以下合并碎片，同时压缩表，不移动高水位。
```
但是美中不足的是move不移动高水位，并且还要重建索引。

在10g的时候候提供了shrink space
shrink space碎片整理功能不仅能整理碎片还可以收缩高水位,索引也不需要重建

move不能降低高水位的原因是不能修改`rowid`，而 `alter table shrink space` 是可以修改rowid的

## 二、使用shrink space整理过程

### 1.找出碎片率高的表(>50%)

主要思路
```
SELECT table_name,
       ROUND((blocks * 8/1024), 2) "高水位空间 M",
       ROUND((num_rows * avg_row_len / 1024/1024), 2) "真实使用空间 M",
       ROUND((blocks * 10 / 100) * 8, 2) "预留空间(pctfree) M",
       ROUND((blocks * 8 - (num_rows * avg_row_len / 1024) -blocks * 8 * 10 / 100), 2) "浪费空间 M",
       ((blocks * 8-(num_rows * avg_row_len / 1024))/1024)/(blocks * 8/1024) "浪费空间 %"
  FROM user_tables
 WHERE table_name = 'table_name';
```
在高水位和真实使用的空间之间的差距=浪费空间，而产生浪费空间的原因是高水位的上涨，真实使用的空间变小（大量的delete）而造成的，而这样也会产生大量的碎片。浪费空间 %大于25就需要整理了。

如果以上没有结果,可能是表没有统计信息,可以先收集表的统计信息
```
这个分析很耗时间可以设定estimate_percent来调整分析的量:
exec dbms_stats.gather_table_stats(user,'table_name',CASCADE=>TRUE);
```

生产环境可以使用下面的语句一次性查出需要做碎片整理的表：
```
col OWNER for a10;
col TABLE_NAME for a20;
select * from (select t.owner owner,
t.table_name table_name,
  	 trunc(s.blocks*ts.block_size/1024/1024*1000)/1000 ssize,
TRUNC((num_rows*avg_row_len)*1000/((100-pct_free-5)/100)/1024/1024)/1000 est_size, trunc((s.blocks*ts.block_size)/((num_rows*avg_row_len)/((100-pct_free-5)/100))*100)/100 sp,
  	 last_analyzed,
  	 num_rows,
  	 avg_row_len,
  	 pct_free,
  	 s.blocks
  from dba_tables t,
  	(SELECT owner,segment_name,sum(blocks) blocks from dba_segments
  	where
  	 owner not in ('SYS','OUTLN','SYSTEM','MGMT_VIEW','SYSMAN','DBSNMP','WMSYS','XDB',
  	'DIP','GOLDENGATE','CTXSYS' )
  	group by owner ,segment_name )S,
    dba_tablespaces ts
  where
  	t.tablespace_name=ts.tablespace_name and
  	t.owner=s.owner and t.table_name=s.segment_name and
  	t.num_rows*avg_row_len >0 and
  	t.owner not in ('SYS','OUTLN','SYSTEM','MGMT_VIEW','SYSMAN','DBSNMP','WMSYS','XDB',
  	'DIP','GOLDENGATE','CTXSYS' ) and
  	S.blocks>200 and
  	 t.last_analyzed is not null)
  where sp >=50 order by 3;
```

### 2.开启行迁移
```
alter table table_name enable row movement;
```

### 3.进行碎片整理
```
alter table table_name shrink space cascade;
```
连同索引一起压缩，比move方便。

### 4.再根据实际情况关闭行迁移
```
alter table table_name disable row movement; 
```

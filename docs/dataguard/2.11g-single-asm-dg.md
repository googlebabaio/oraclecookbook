
<!-- toc --> 

* * * * *
## 一、环境说明
本文给出了 模拟asm环境下的dataguard搭建的过程，主备库均采用单实例+asm。
为了模拟可能遇到的情况，增加一个难度，让主备两边的磁盘组的名字不一样。
主库：+DATA ,  +ARCH
备库：+ORADATA ， +ARCHDATA
dg搭建前提：主库已经创建了实例nazeebo，备库已经安装好数据库软件，两个库都采用asm进行管理。

> 如何在11g单机采用asm管理，请参考：11g单机安装asm

## 二、采用技术说明

|  序号  |技术选型    |理由说明    |
| --- | --- | --- |
| 1   | 备库的恢复采用rman的全备+增量备份进行恢复   |  (1)考虑到数据量较大和网络因素，故而不采用man的特性duplicate for standby database；(2)考虑到一次时间窗口有不能完成dataguard备库的配置，故而可以考虑利用rman全备先去做恢复，然后在实际时间窗口前用追补归档的方式恢复备库，使得备库的数据尽可能和主库一致，减少采用的时间操作的时间窗口|
|  2  | 使用dg broker进行配置   |  (1)因为要考虑到切换，而如果是采用命令行的方式可能会造成被初始化参数搞混，所以采用Oracle官方推荐的dg broker进行配置和管理 ；(2)考虑到配置的简洁性，采用dg broker仅仅需要配置很少的几个初始化参数|
| 3   |  使用dg broker进行管理(如切换)  |  操作简单易用  |


## 三、简要配置流程说明

| 步骤   | 操作内容   |  备注  |
| --- | --- | --- |
|   1 | 提前对备库进行数据库环境的安装以及相应目录的创建，不需要创建实例   |  此项工作不占用双活配置操作时间窗口  |
|   2 |  提前配置好主库以及备库的listener.ora 和 tnsnames.ora，并需要确保能互相之间tnsping通  |  此项工作不占用双活配置操作时间窗口  |
|  3  |  对主库和dataguard相关的初始化参数进行配置，并在主库上创建standby redo log group  |    |
|  4  |  生成主库的pfile.bak、创建standby control file  |    |
|  5  | 将主库的pfile.bak、standby control file和密码文件传到备库的相应位置上   |    |
|  6  |  在备库修改传过来的pfile.bak ，修改好用这个pfile将数据库启动到nomount状态，创建spfile，再重启备库到nomount状态  |    |
|  7  |   对主库进行rman全备 |    |
|  8  | 将主库的全备传输到备库上   |    |
| 9   |  在备库上利用rman进行standby control file的恢复，并将备库修改到mount状态  |    |
|  10  |  用rman对备库进行restore恢复，恢复完成后不打开备库 （在这个过场中如果主库没有停止业务，那么有可能会有新的归档日志生成，那么需要将新生成的归档日志传递过来并进行恢复） |   rman恢复不会生成redo log，这个在之后调用broker会帮这创建，这个时候的alert报错可以暂时不用去管 |
| 11 | 在主库做全备到在备库传输以及恢复这段时间，业务会产生相应的日志，将这些日志归档(归档日志)传输到备库，进行归档日志的追补	   |    |
|  12 |   在备库打开日志应用 |  alter database recover managed standby database using current logfile disconnect;  |
| 13 |  在主库和备库分别打开dg_broker_start  |   alter system set dg_broker_start=true; |
|  14 | 在主库上登录dg broker的命令行管理端   |    dgmgrl sys/密码@tnsnames|
| 15  |  创建配置信息  |  create configuration  |
|  16 |  添加备库的信息  |   add database |
| 17  |   启用配置 |  这一步很重要，所有的参数修改都是在这个命令发出后才进行实质的修改，这个时候可以对alert日志进行跟踪  |
|18 | 检查主库备库的alert日志是否有报错|    |
|19 | 测试主库与备库的dataguard是否配置成功|    |
|20 | 做一些switchover的相关测试|    |
|21 |根据需要看是否需要加上归档日志的清理脚本等|    |


## 四、详细搭建过程

### 4.1.环境准备

|  序号  | 角色   |操作系统    |数据库版本    | 主机名   |实例名    |tnsnames    |备注    |
| --- | --- | --- | --- | --- | --- | --- | --- |
|1    |   主库 | Redhat6.8   | 11.2.0.4   |  nazeebo  |  nazeebo  |nazeebo    |    |
|  2  |   备库 |   Redhat6.8 |  11.2.0.4  | lowa   | lowa   | lowa   |    |


### 4.2 主备库都需要做的工作
#### 4.2.1 监听配置
修改监听，配置静态监听，因为后面要用到的dg broker，所以静态监听中添加GLOBAL_DBNAME = 实例名_DGMGRL 这一个监听。又因为采用了asm管理，需要将ORACLE_HOME修改为oracle用户的ORACLE_HOME的路径（默认为grid用户的ORACLE_HOME路径）
主库监听
```
[grid@nazeebo admin]$ more listener.ora
# listener.ora Network Configuration File: /u01/app/11.2.0.4/grid/network/admin/listener.ora
# Generated by Oracle configuration tools.

LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
      (ADDRESS = (PROTOCOL = TCP)(HOST = nazeebo)(PORT = 1521))
    )
  )

SID_LIST_LISTENER =  
  (SID_LIST =  
    (SID_DESC =  
      (GLOBAL_DBNAME = nazeebo)  
      (ORACLE_HOME = /u01/app/oracle/product/11.2.0.4/db_1)  
      (SID_NAME = nazeebo)  
    )  
    (SID_DESC =  
      (GLOBAL_DBNAME = nazeebo_DGMGRL)  
      (ORACLE_HOME = /u01/app/oracle/product/11.2.0.4/db_1)  
      (SID_NAME = nazeebo)  
    )  
  )  


ADR_BASE_LISTENER = /u01/app/grid

ENABLE_GLOBAL_DYNAMIC_ENDPOINT_LISTENER=ON		# line added by Agent

```
备库监听
```
[grid@lowa admin]$ more listener.ora
# listener.ora Network Configuration File: /u01/app/11.2.0.4/grid/network/admin/listener.ora
# Generated by Oracle configuration tools.

LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
      (ADDRESS = (PROTOCOL = TCP)(HOST = lowa)(PORT = 1521))
    )
  )


SID_LIST_LISTENER =  
  (SID_LIST =  
    (SID_DESC =  
      (GLOBAL_DBNAME = lowa)  
      (ORACLE_HOME = /u01/app/oracle/product/11.2.0.4/db_1)  
      (SID_NAME = lowa)  
    )  
    (SID_DESC =  
      (GLOBAL_DBNAME = lowa_DGMGRL)  
      (ORACLE_HOME = /u01/app/oracle/product/11.2.0.4/db_1)  
      (SID_NAME = lowa)  
    )  
  )
ADR_BASE_LISTENER = /u01/app/grid

ENABLE_GLOBAL_DYNAMIC_ENDPOINT_LISTENER=ON		# line added by Agent

```
#### 4.2.2 配置tnsnames.ora
主库和备库保持一致
```
[oracle@nazeebo admin]$ cat tnsnames.ora 
# tnsnames.ora Network Configuration File: /u01/app/oracle/product/11.2.0.4/db_1/network/admin/tnsnames.ora
# Generated by Oracle configuration tools.

NAZEEBO =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = nazeebo)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = nazeebo)
    )
  )

lowa =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = lowa)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = lowa)
    )
  )
```

### 4.3 主库准备工作
#### 4.3.1 修改初始化参数
只需要配置简简单单的5个参数，就可以搞定（剩下的broker会帮你补全）

```
参数1：alter system set log_archive_dest_1='location=+ARCH MANDATORY';
参数2：alter system set log_archive_dest_2='service=lowa LGWR ASYNC';
参数3：alter system set db_file_name_convert='+ORADATA/lowa','+DATA/nazeebo','+ARCHDATA/lowa','+ARCH/nazeebo' scope=spfile;
参数4：alter system set log_file_name_convert='+ORADATA/lowa','+DATA/nazeebo','+ARCHDATA/lowa','+ARCH/nazeebo' scope=spfile;
参数5：alter system set standby_file_management=AUTO;
```
说明一点，参数1设置本地归档路径，只需要设置归档的磁盘，剩下的asm会自动帮助补全，以下为验证这一点：
```
SQL> alter system set log_archive_dest_1='location=+ARCH MANDATORY';
System altered.
SQL> 
SQL> alter system switch logfile;

System altered.
============================================================
ASMCMD> pwd
+arch/nazeebo/archivelog/2018_05_10
ASMCMD> ls
thread_1_seq_59.260.975790853
thread_1_seq_60.261.975791067
thread_1_seq_61.262.975791103
thread_1_seq_62.263.975791337
ASMCMD> ls
thread_1_seq_59.260.975790853
thread_1_seq_60.261.975791067
thread_1_seq_61.262.975791103
thread_1_seq_62.263.975791337
```
如上所示，修改为+ARCH后，磁盘组相对应的目录自己生成了全路径“+arch/nazeebo/archivelog/”
另外，对应xxx_file_convert的顺序可能会记错，有一个诀窍：对端写前面。
#### 4.3.2 数据库级的一些设置
##### 4.3.2.1 强制归档
```
alter database force logging;
```
##### 4.3.2.2 启用最小补充日志
```
alter database add supplemental log data ;
select supplemental_log_data_min min from v$database ;
```
> 需要注意的是，凡是启用或者关闭数据库级补充日志(包括最小补充日志和另外几种日志)都会导致共享池中所有SQL命令游标非法，也就是短期之内应解析会显著上升。
##### 4.3.2.3 开启闪回
```
alter database flashback on;
```
后期如果有可能开启snapshot standby的话，建议开启

#### 4.3.3 添加standby redo log
* 因为需要做switchover的切换，所以需要配置standby redo log，这个的组数是(redo的个数+1)*每组成员数，这个测试环境是3组redo log，所以就建立4组standby redo log就可以了。注意日志大小参照redo log的大小，保持一致。
* RAC环境两个节点分别都要添加同样多的组数以及同样大小，用thread关键字来确定是哪一个节点。
* RAC环境下，主库应该添加（N+1）*2组，其中N 为主库两个分区中配置的最大redolog 组数。

```
ALTER DATABASE ADD STANDBY LOGFILE GROUP 4 ('+DATA','+ARCH') size 50M; 
ALTER DATABASE ADD STANDBY LOGFILE GROUP 5 ('+DATA','+ARCH') size 50M;  
ALTER DATABASE ADD STANDBY LOGFILE GROUP 6 ('+DATA','+ARCH') size 50M;  
ALTER DATABASE ADD STANDBY LOGFILE GROUP 7 ('+DATA','+ARCH') size 50M;  
```

####  4.3.4 创建pfile的备份
```
create pfile='/home/oracle/pfile.bak' from spfile;
```

#### 4.3.5 创建standby control file
```
alter database create standby controlfile as '/home/oracle/standby.ctl';
```

#### 4.3.6 传递相关文件到备库
* 传递pfile.bak到备库
* 传递密码文件到备库，并修改密码文件的名字为备库的实例
* 传递standby control file到备库

给一个主库的参考pfile
```
[oracle@nazeebo ~]$ cat pfile.bak 
nazeebo.__db_cache_size=1929379840
nazeebo.__java_pool_size=16777216
nazeebo.__large_pool_size=33554432
nazeebo.__pga_aggregate_target=838860800
nazeebo.__sga_target=2516582400
nazeebo.__shared_io_pool_size=0
nazeebo.__shared_pool_size=503316480
nazeebo.__streams_pool_size=0
*.audit_file_dest='/u01/app/oracle/admin/nazeebo/adump'
*.audit_trail='db'
*.compatible='11.2.0.4.0'
*.control_files='+DATA/nazeebo/controlfile/current.259.975754453','+ARCH/nazeebo/controlfile/current.256.975754453'
*.db_block_size=8192
*.db_create_file_dest='+DATA'
*.db_domain=''
*.db_file_name_convert='+ORADATA/lowa','+DATA/nazeebo','+ARCHDATA/lowa','+ARCH/nazeebo'
*.db_name='nazeebo'
*.db_recovery_file_dest='+ARCH'
*.db_recovery_file_dest_size=5218762752
*.diagnostic_dest='/u01/app/oracle'
*.dispatchers='(PROTOCOL=TCP) (SERVICE=nazeeboXDB)'
*.log_archive_dest_1='location=+ARCH MANDATORY'
*.log_archive_dest_2='service=lowa LGWR ASYNC'
*.log_archive_format='%t_%s_%r.dbf'
*.log_file_name_convert='+ORADATA/lowa','+DATA/nazeebo','+ARCHDATA/lowa','+ARCH/nazeebo'
*.open_cursors=300
*.pga_aggregate_target=838860800
*.processes=150
*.remote_login_passwordfile='EXCLUSIVE'
*.sga_target=2516582400
*.standby_file_management='AUTO'
*.undo_tablespace='UNDOTBS1'
```


### 4.4 备库配置
#### 4.4.1 修改pfile文件
主要注意几个参数必需修改：

|  序号  |  修改参数  |  说明  |
| --- | --- | --- |
|  1  |   .db_name |   保持和主库的一致，只有一致了，物理standby才能正确配置。参考值：nazeebo|
|   2 |  .db_unique_name   | 写备库的实例名，要区别主库的实例名。参考值：lowa|
|    3|   log_archive_dest_1 |  写本地的归档路径，参考值：Location=  \`+ARCHDATA\`|
|   4 | log_archive_dest_2   |   写主库的归档路径，参考值：log_archive_dest_2='service=nazeebo LGWR ASYNC' 。**注意**：service对应的名字写的tnsnames的名字，而非实例名。 |
|   5 |  db_file_name_convert  |  参考值：db_file_name_convert='+DATA/nazeebo','+ORADATA/lowa','+ARCH/nazeebo','+ARCHDATA/lowa'|
|   6 |  log_file_name_convert  | 同db_file_name_convert   |
|   7 |  audit_file_dest  |  填写实际想放置的位置，如果在RAC+ASM，需要先提前创建磁盘组，再修改   |
|   8 | control_files   |  填写实际想放置的位置，如果在RAC+ASM，需要先提前创建磁盘组，再修改  |

给一个备库的参考pfile
```
[oracle@lowa ~]$ cat pfile.bak 
lowa.__db_cache_size=1929379840
lowa.__java_pool_size=16777216
lowa.__large_pool_size=33554432
lowa.__pga_aggregate_target=838860800
lowa.__sga_target=2516582400
lowa.__shared_io_pool_size=0
lowa.__shared_pool_size=503316480
lowa.__streams_pool_size=0
*.audit_file_dest='/u01/app/oracle/admin/lowa/adump'
*.audit_trail='db'
*.compatible='11.2.0.4.0'
*.control_files='+ORADATA/lowa/controlfile/control.ctl','+ARCHDATA/lowa/controlfile/control.ctl'
*.db_block_size=8192
*.db_create_file_dest='+ORADATA'
*.db_domain=''
*.db_file_name_convert='+DATA/nazeebo','+ORADATA/lowa','+ARCH/nazeebo','+ARCHDATA/lowa'
*.db_name='nazeebo'
*.db_unique_name='lowa'
*.db_recovery_file_dest='+ARCHDATA'
*.db_recovery_file_dest_size=5218762752
*.diagnostic_dest='/u01/app/oracle'
#*.dispatchers='(PROTOCOL=TCP) (SERVICE=lowaXDB)'
*.log_archive_dest_1='location=+ARCHDATA MANDATORY'
*.log_archive_dest_2='service=nazeebo LGWR ASYNC'
*.log_archive_format='%t_%s_%r.dbf'
*.log_file_name_convert='+DATA/nazeebo','+ORADATA/lowa','+ARCH/nazeebo','+ARCHDATA/lowa'
*.open_cursors=300
*.pga_aggregate_target=838860800
*.processes=150
*.remote_login_passwordfile='EXCLUSIVE'
*.sga_target=2516582400
*.standby_file_management='AUTO'
*.undo_tablespace='UNDOTBS1'
```

#### 4.4.2 创建相应的目录
备库有些目录是没有建立好的，需要提前建立，非asm的参考如下：
至少应该添加的目录有：*数据文件、adump、归档日志、闪回区*
```
mkdir -p /u01/app/oracle/oradata/nazeebo 
mkdir -p /u01/app/oracle/admin/nazeebo/adump
mkdir -p /u01/app/oracle/archivelog/nazeebo
mkdir -p /u01/app/oracle/fast_recovery_area/nazeebo
```
而asm管理的数据库，需要进入到相应的磁盘组创建或者用sqlplus的命令进行创建
用asmcmd命令添加目录，示例：
```
shell> asmcmd
shell> cd +DATA
shell> mkdir archivelog
shell> cd archivelog
shell> mkdir nazeebo
```
用sql命令添加目录，示例：
```
--首先添加nazeebo
SQL> alter diskgroup datadg01 add directory '+datadg01/nazeebo/';

然后添加datafile
SQL> alter diskgroup datadg01 add directory '+datadg01/nazeebo/datafile';
```

#### 4.4.3 通过spfile启动数据库到nomount状态
```
sql> startup pfile=’/home/oracle/pfile.bak’ nomount
```
在这一步也可以顺便检查之前的目录有没有创建正确
启动完成无异常后，创建spfile，再以spfile的方式启动到nomount状态
```
sql> create spfile from pfile=’/home/oracle/pfile.bak’;
sql> startup nomount
```

#### 4.4.4 恢复standby控制文件
```
rman > restore controlfile from '/home/oracle/standby.ctl';
```
这一步可以检查control放置的路径是否正确创建了的，如果有报错请troubleshooting

#### 4.4.5 启动备库到mount状态
```
sql> alter database mount;
```
备注：只有在mount状态了，才可以利用rman进行数据库的恢复，来达到初始化的目的

### 4.5 配置dataguard
#### 4.5.1 对主库进行全备，并将备份传递到备库
参考脚本如下：
```
run {
  allocate channel c1 type disk;
  allocate channel c2 type disk;
  allocate channel c3 type disk;
  allocate channel c4 type disk;
  backup  database format '/home/oracle/rmandir/FULL_%U.bak' ;
  backup  archivelog  all format '/home/oracle/rmandir/ARC_%U.bak';
  release channel c1;
  release channel c2;
  release channel c3;
  release channel c4;
}
```
> 备注：
> 在本文中，是在主备库创建了一个/home/oracle/rmandir目录，所有的备份文件都放在这个目录中。对于分配的channel，以根据实际的情况来进行增删。
> 另外，需要注意的是准备足够的磁盘空间进行rman的全备。

#### 4.5.2 在备库进行restore的恢复
进入到备份的目录，然后在备库进行restore的恢复，参考脚本如下：
```
rman> 
run {
allocate channel c1 type disk;
allocate channel c2 type disk;
allocate channel c3 type disk;
allocate channel c4 type disk;
restore database ;
release channel c1;
release channel c2;
release channel c3;
release channel c4;
}

```
> 因为restore会将主库创建的standby redo log也恢复到备库，所以务必保证主库初始化参数log_file_name_convert的正确性。

#### 4.5.3 追补日志
```
RMAN> restore archivelog all;
```

#### 4.5.4 在备库开始redo apply
在保证恢复正常之后，在备库开始redo apply
```
SQL> alter database recover managed standby database using current logfile disconnect;
```

### 4.6 配置dg broker
以上的步骤只是完成了一半的配置，接下来需要利用dg broker完成剩下的一半工作

#### 4.6.1 分别在主备库开启dg broker
```
alter system set dg_broker_start=true;
```

#### 4.6.2 在主库登陆dg broker
所有的操作都只需要在主库上进行
```
[oracle@nazeebo ~]$ dgmgrl sys/Oracle123@nazeebo
DGMGRL for Linux: Version 11.2.0.4.0 - 64bit Production

Copyright (c) 2000, 2009, Oracle. All rights reserved.

Welcome to DGMGRL, type "help" for information.
Connected.
```

#### 4.6.3 创建配置信息
```
DGMGRL> create CONFIGURATION cfg_1 as PRIMARY DATABASE IS nazeebo CONNECT IDENTIFIER IS nazeebo;
Configuration "cfg_1" created with primary database "nazeebo"
```

#### 4.6.4 添加备库信息
```
DGMGRL> add DATABASE lowa as CONNECT IDENTIFIER IS lowa ; 
Database " lowa " added
```

#### 4.6.5 启动配置
这一步是真正的使得配置生效
```
DGMGRL> ENABLE CONFIGURATION;
```
> 备注：
> 这个时候，最好将主库和备库的alert日志都打开进行跟踪

#### 4.6.6 查看配置信息
```
DGMGRL> show CONFIGURATION;

Configuration - cfg_1

  Protection Mode: MaxPerformance
  Databases:
    nazeebo - Primary database
    lowa    - Physical standby database

Fast-Start Failover: DISABLED

Configuration Status:
SUCCESS

DGMGRL> 

```

#### 4.6.7 测试配置是否正确生效
在主库进行测试表的创建，看在备库上是否能看到。

### 4.7 切换操作
通过broker可以很容易的坐到切换snapshot db，switchover切换，failover切换。
在以前通过命令切换的时候，首先要检查状态，然后在主库和备库都要敲命令才能实现以上说的切换。
而通过dg broker来进行切换，只需要一条命令：
```
1.查看当前配置信息
DGMGRL> show configuration

Configuration - cfg_1

  Protection Mode: MaxPerformance
  Databases:
    lowa    - Primary database
    nazeebo - Physical standby database

Fast-Start Failover: DISABLED

Configuration Status:
SUCCESS


2.做switchover
DGMGRL> help switchover

Switches roles between a primary and standby database

Syntax:

  SWITCHOVER TO <standby database name>;

DGMGRL> switchover to lowa;
Performing switchover NOW, please wait...
Operation requires a connection to instance "lowa" on database "lowa"
Connecting to instance "lowa"...
Connected.
New primary database "lowa" is opening...
Operation requires startup of instance "nazeebo" on database "nazeebo"
Starting instance "nazeebo"...
ORACLE instance started.
Database mounted.
Database opened.
Switchover succeeded, new primary is "lowa"

3.做完之后查看新的配置信息
DGMGRL> show configuration

Configuration - cfg_1

  Protection Mode: MaxPerformance
  Databases:
    lowa    - Primary database
    nazeebo - Physical standby database

Fast-Start Failover: DISABLED

Configuration Status:
SUCCESS

```

## 五、常用维护操作
### 5.1 备库退出redo应用状态
```
SQL> alter database recover managed standby database cancel;
Database altered.
```
PS：停止standby的redo应用，此时只是暂停redo 应用，并不是停止Standby 数据库，standby 仍然会保持接收只不过不会再应用接收到的归档，直到再次启动redo 应用为止。类似mysql里面的stop slave功能;

### 5.2 打开standby上的oracle库
```
SQL> alter database open;
Database altered. 
再应用redo日志
SQL> alter database recover managed standby database using current logfile disconnect ;
```
### 5.3 查看Data Guard数据库运行在哪种模式下：
```
在主库上：
sql>select DATABASE_ROLE,PROTECTION_MODE,PROTECTION_LEVEL from v$database;
DATABASE_ROLE PROTECTION_MODE PROTECTION_LEVEL
---------------- -------------------- --------------------
PRIMARY MAXIMUM PERFORMANCE MAXIMUM PERFORMANCE

在备库上：
sql>select DATABASE_ROLE,PROTECTION_MODE,PROTECTION_LEVEL from v$database;
DATABASE_ROLE PROTECTION_MODE PROTECTION_LEVEL
---------------- -------------------- --------------------
PHYSICAL STANDBY MAXIMUM PERFORMANCE MAXIMUM PERFORMANCE
```
### 5.4 在备机查看日志序列和被应用的状态 
```
sql>select sequence#,applied from v$archived_log where applied=’YES’;
```
### 5.5 查看Data Guard Standby 后台恢复进程是否正常
```
在备机上：
$ps -ef |grep mrp
输出结果应该有mrp的后台进程
```
### 5.6 查询主库日志与备库是否一致
```
SQL> select sequence# from v$archived_log where recid = (select max(recid) from v$archived_log) and applied = 'YES';
SQL> select sequence# from v$archived_log where recid = (select max(recid) from v$archived_log);
```
### 5.7 查看主库的归档日志的状态：	
```
SQL> select dest_name,status,error from v$archive_dest where rownum<3;
DEST_NAME STATUS ERROR 
-------------------- --------- -------------------------------
LOG_ARCHIVE_DEST_1 VALID
LOG_ARCHIVE_DEST_2 ERROR ORA-16191: Primary log shipping client not logged on standby
```
### 5.8 备库需要手工生成standby redo log吗？
答案是不需要的，如果主库创建了standby redo log，那么在用rman进行备库生成的时候，备库自动会生成standby redo log
如下：
```
SQL> select * from v$logfile;

    GROUP# STATUS	  TYPE		 MEMBER 					    IS_REC
---------- -------------- -------------- -------------------------------------------------- ------
	 1		  ONLINE	 +ORADATA/lowa/onlinelog/group_1.265.975795255	    NO
	 1		  ONLINE	 +ARCHDATA/lowa/onlinelog/group_1.272.975795257     YES
	 2		  ONLINE	 +ORADATA/lowa/onlinelog/group_2.266.975795257	    NO
	 2		  ONLINE	 +ARCHDATA/lowa/onlinelog/group_2.273.975795259     YES
	 3		  ONLINE	 +ORADATA/lowa/onlinelog/group_3.267.975795259	    NO
	 3		  ONLINE	 +ARCHDATA/lowa/onlinelog/group_3.274.975795261     YES
	 7		  STANDBY	 +ORADATA/lowa/onlinelog/group_7.257.975794407	    NO
	 7		  STANDBY	 +ARCHDATA/lowa/onlinelog/group_7.257.975794409     YES
	 4		  STANDBY	 +ORADATA/lowa/onlinelog/group_4.258.975794407	    NO
	 4		  STANDBY	 +ARCHDATA/lowa/onlinelog/group_4.258.975794409     YES
	 5		  STANDBY	 +ORADATA/lowa/onlinelog/group_5.259.975794411	    NO
	 5		  STANDBY	 +ARCHDATA/lowa/onlinelog/group_5.260.975794413     YES
	 6		  STANDBY	 +ORADATA/lowa/onlinelog/group_6.260.975794411	    NO
	 6		  STANDBY	 +ARCHDATA/lowa/onlinelog/group_6.261.975794413     YES

14 rows selected.

SQL> 

```

### 5.9 检查Standby数据库上是否归档有被应用：
在备库上查看 是否有mrp进程

```
SQL> select process,status from v$managed_standby;

PROCESS 	   STATUS
------------------ ------------------------
ARCH		   CONNECTED
ARCH		   CONNECTED
ARCH		   CONNECTED
ARCH		   CLOSING
RFS		   IDLE
RFS		   IDLE
RFS		   IDLE
MRP0		   APPLYING_LOG

8 rows selected.
```
 
如果没有MRP进程，说明没有开启为 recover managed standby database状态 ; 
可以使用  alter database recover managed standby database disconnect from session ; 开standby。
 
> MRP就是备库的恢复进程
> RFS进程接受从主库来的日志
> 没有MRP进程，说明备库没有处于恢复状态
